---
emoji: 📚
title: n8n으로 블로그 게시글 초안을 자동 생성해보자
date: '2025-12-28'
author: JH8459
categories: Backend
thumbnail: https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-12-28/Backend/thumbnail.png
---

<!-- AI_BRIEF_START
이 글은 n8n과 Gemini 2.5 Pro, 그리고 별도의 agent-server를 조합해 기술 블로그 게시글 초안을 자동으로 생성하는 구조를 설계하고 구현한 경험을 정리한 글이다.

단순히 n8n의 기능이나 사용법을 나열하는 튜토리얼이 아니라, 왜 블로그 게시글 자동화를 고민하게 되었는지, 기존의 수동 작성 방식에는 어떤 한계가 있었는지, 그리고 실제로 자동화를 구성하면서 어떤 설계적 선택과 책임 분리가 필요했는지를 중심으로 설명하고자 한다.

특히 이 글에서는 LLM에게 모든 것을 맡기지 않고, 메타 정보와 파일 생성은 서버가 책임지고, 게시글의 방향성과 구조는 사람이 직접 정의하며, 본문 초안만을 LLM이 생성하도록 한 이유를 중요하게 다룬다.

독자는 이미 기술 블로그를 운영하고 있거나 n8n 혹은 LLM 기반 자동화에 관심이 있는 백엔드 개발자이며, "이런 자동화가 실제로 실무에서 쓸 만한가?"라는 관점에서 이 글을 읽게 된다.

최종적으로는 n8n + agent-server + Gemini 2.5 Pro 조합에서 어디까지 자동화하고, 어디서 사람이 개입하는 구조가 현실적인지에 대한 하나의 기준과 사고 과정을 공유하는 것이 목적이다.
AI_BRIEF_END -->

<!-- AI_OUTLINE_START
📚 Overview: 왜 블로그 게시글 자동화를 고민하게 되었는가
기존 기술 블로그 작성 방식의 한계
n8n을 선택한 이유와 전체 자동화 흐름
agent-server의 역할과 책임 분리
Gemini 2.5 Pro를 LLM으로 선택한 이유
brief와 outline을 입력 단계에서 고정한 이유
자동 생성된 게시글 초안의 품질과 한계
🤔 Understanding: 어디까지 자동화하고, 어디서 사람이 개입해야 할까
AI_OUTLINE_END -->

<img src="https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-12-28/Backend/banner.png"/>

## 📚 Overview: 왜 블로그 게시글 자동화를 고민하게 되었는가

기술 블로그를 꾸준히 운영하는 것은 개발자에게 중요한 활동이지만, 생각보다 많은 시간과 에너지가 소요됩니다. 특히 아이디어를 구체적인 글로 옮기는 과정에서 '빈 페이지'를 마주하는 막막함은 글쓰기를 주저하게 만드는 가장 큰 허들 중 하나입니다. 파일 생성, 날짜와 슬러그(slug) 설정, YAML frontmatter 작성 등 본문 작성 이전에 거쳐야 하는 자잘하고 반복적인 작업들도 생각보다 큰 인지 부하를 유발합니다.

이 글은 이러한 문제를 해결하기 위해 n8n, Gemini 2.5 Pro, 그리고 별도의 `agent-server`를 조합하여 기술 블로그 게시글 초안을 자동으로 생성하는 시스템을 구축한 경험을 공유합니다. 단순히 '어떻게' 만들었는지를 나열하는 튜토리얼이 아닙니다. 대신, 왜 이런 자동화를 고민하게 되었는지, 기존 방식의 어떤 점이 비효율적이었는지, 그리고 시스템을 설계하며 내렸던 선택들과 그에 따른 트레이드오프는 무엇이었는지에 초점을 맞춥니다. 이 자동화의 핵심은 LLM에게 모든 것을 맡기는 것이 아니라, 명확한 책임 분리를 통해 '제어 가능한' 자동화를 구현하는 것입니다.

## 왜 블로그 게시글 자동화를 고민하게 되었는가

모든 개발자가 그렇듯, 저 또한 반복적인 작업을 자동화하는 것을 선호합니다. 기술 블로그 작성 과정에는 의외로 많은 반복이 숨어있습니다. 새로운 글을 시작할 때마다 `_posts` 디렉터리에 `YYYY-MM-DD-my-new-post.md` 형식의 파일을 만들고, 기존 글에서 YAML frontmatter를 복사해와 `title`, `date`, `category`, `slug` 등의 메타 정보를 수정하는 작업이 대표적입니다. 이 과정은 몇 분 걸리지 않지만, 글쓰기라는 창의적인 활동을 시작하기 전에 거쳐야 하는 일종의 '의식'처럼 느껴지며 집중력을 흩트러뜨립니다.

더 큰 문제는 '초안 작성' 단계입니다. 머릿속에 글의 대략적인 구조와 핵심 메시지가 있어도, 이를 문장으로 풀어내는 것은 완전히 다른 차원의 일입니다. 특히 컨디션이 좋지 않거나 다른 업무로 바쁠 때는 이 초기 단계에서 막혀 글쓰기를 포기하는 경우가 많았습니다. 만약 이 지루한 준비 과정과 막막한 초안 작성 단계를 자동화할 수 있다면, 저는 글의 핵심 아이디어와 저의 경험을 녹여내는 더 중요한 작업에만 집중할 수 있을 것이라 생각했습니다. 즉, 자동화의 목표는 '글을 대신 쓰게 하는 것'이 아니라 '글을 더 쉽게, 더 자주 쓸 수 있는 환경을 만드는 것'이었습니다.

## 기존 기술 블로그 작성 방식의 한계

기존의 수동 작성 방식은 명확한 한계를 가지고 있었습니다. 전체 프로세스를 단계별로 나누어 보면 문제점이 더 잘 보입니다.

1.  **아이디어 구상**: 어떤 주제로 글을 쓸지 결정합니다. (창의적 영역)
2.  **파일 및 메타데이터 준비**: `YYYY-MM-DD-slug.md` 파일을 생성하고 YAML frontmatter를 채웁니다. (기계적/반복적 영역)
3.  **개요(Outline) 작성**: 글의 뼈대가 될 구조를 잡습니다. (창의적/구조적 영역)
4.  **초안 작성**: 개요를 바탕으로 각 섹션의 내용을 채워나갑니다. (노동 집약적 영역)
5.  **퇴고 및 발행**: 초안을 다듬고, 이미지를 추가하며, 최종적으로 발행합니다. (창의적/검토 영역)

여기서 가장 큰 병목은 2번과 4번입니다. 2번은 사소하지만 글쓰기의 시작을 방해하는 마찰(friction)을 일으킵니다. 4번은 가장 많은 시간과 정신적 에너지를 요구하며, '작가 장벽(writer's block)'이 발생하는 주된 구간입니다. 이 두 단계를 자동화 시스템이 해결해준다면, 저는 1번, 3번, 5번이라는 훨씬 더 가치 있는 활동에 집중할 수 있게 됩니다. 자동화를 통해 '기계가 잘하는 일'과 '사람이 잘하는 일'을 분리하고, 글쓰기 과정의 효율을 극대화하는 것이 목표였습니다.

## n8n을 선택한 이유와 전체 자동화 흐름

이러한 자동화 워크플로우를 구현하기 위한 오케스트레이션 도구로 n8n을 선택했습니다. 코드로 직접 스크립트를 작성할 수도 있었지만, n8n은 몇 가지 뚜렷한 장점을 제공했습니다. 첫째, 워크플로우를 시각적인 노드(node) 기반으로 설계할 수 있어 전체 흐름을 한눈에 파악하고 수정하기 용이합니다. 둘째, 웹훅(Webhook) 트리거, HTTP 요청, 데이터 변환 등 다양한 기본 노드를 제공하여 여러 서비스를 쉽게 연동할 수 있습니다. 마지막으로, 자체 호스팅이 가능하여 민감한 정보나 API 키를 외부 서비스에 의존하지 않고 관리할 수 있다는 점도 매력적이었습니다.

전체 자동화 흐름은 다음과 같이 설계했습니다.

1.  **트리거**: 사용자는 `title`, `brief`, `outline`이 포함된 JSON 데이터를 n8n의 웹훅 URL로 전송합니다. 이 작업은 간단한 cURL 명령어 나 Postman으로 실행할 수 있습니다.
2.  **메타데이터 생성 요청**: n8n은 웹훅으로 받은 `title`을 `agent-server`의 `/prepare` 엔드포인트로 전달합니다. `agent-server`는 `title`을 기반으로 `slug`, `filename`, `date` 등 필요한 메타데이터를 생성하여 반환합니다.
3.  **LLM 초안 생성 요청**: n8n은 입력받은 `brief`와 `outline`, 그리고 `agent-server`로부터 받은 메타데이터를 조합하여 Gemini 2.5 Pro API에 전달할 프롬프트를 구성합니다. 그리고 API를 호출하여 블로그 본문 초안을 생성합니다.
4.  **파일 생성 요청**: n8n은 생성된 본문 초안과 2단계에서 받은 메타데이터를 `agent-server`의 `/create` 엔드포인트로 전달합니다.
5.  **파일 저장**: `agent-server`는 전달받은 모든 정보를 조합하여 최종 마크다운(`.md`) 파일을 서버의 지정된 경로(예: `_posts` 디렉터리)에 저장합니다.

<!-- ILLUSTRATION: diagram -->

이 구조에서 n8n은 각 서비스(agent-server, Gemini API)를 순서에 맞게 호출하고 데이터를 전달하는 '지휘자'의 역할을 수행합니다.

## agent-server의 역할과 책임 분리

"왜 굳이 별도의 `agent-server`를 만들었을까? n8n의 'Execute Command' 노드나 'Function' 노드로 파일 시스템을 직접 제어하면 되지 않을까?" 라고 생각할 수 있습니다. 실제로 초기에는 그렇게 접근했지만, 몇 가지 문제에 부딪혔습니다. n8n은 워크플로우 '오케스트레이터'이지, 범용 프로그래밍 환경이 아닙니다. 복잡한 문자열 처리(예: 한글 포함 슬러그 생성), 파일 시스템 접근, 환경 변수 관리 등은 n8n 내부에서 처리하기 번거롭고 유연성이 떨어집니다.

그래서 명확한 책임 분리 원칙을 적용했습니다.

*   **n8n**: 워크플로우의 **흐름(Flow) 제어**를 책임집니다. 언제, 어떤 순서로, 어떤 데이터를 가지고 각 컴포넌트를 호출할지를 결정합니다.
*   **agent-server**: **실행(Execution) 로직**을 책임집니다. 슬러그를 만드는 구체적인 방법, 파일을 어떤 경로와 이름으로 저장할지에 대한 규칙 등 블로그 시스템에 종속적인 로직을 모두 캡슐화합니다.
*   **LLM (Gemini)**: **콘텐츠 생성**을 책임집니다. 주어진 맥락과 구조에 맞춰 텍스트를 생성하는 역할에만 집중합니다.

이렇게 책임을 분리함으로써 얻는 이점은 명확합니다. 첫째, **유지보수성**이 향상됩니다. 만약 블로그의 파일 저장 구조가 변경되더라도 n8n 워크플로우는 건드리지 않고 `agent-server`의 코드만 수정하면 됩니다. 둘째, **재사용성**이 높아집니다. `agent-server`는 n8n뿐만 아니라 다른 클라이언트(예: 슬랙봇, CLI 툴)에서도 동일한 기능을 제공하는 API 서버 역할을 할 수 있습니다. 이는 n8n을 단순한 오케스트레이터로, `agent-server`를 상태와 로직을 가진 마이크로서비스로 바라보는 설계입니다.

## Gemini 2.5 Pro를 LLM으로 선택한 이유

초안 생성을 위한 LLM으로는 Google의 Gemini 2.5 Pro를 선택했습니다. 물론 OpenAI의 GPT-4o나 Anthropic의 Claude 3 Opus 등 다른 훌륭한 모델도 존재합니다. 특정 모델이 절대적으로 우월하다기보다는, 이 프로젝트의 요구사항에 Gemini 2.5 Pro가 잘 부합했다고 판단했습니다.

가장 큰 이유는 **긴 컨텍스트와 뛰어난 지시 이행(Instruction Following) 능력** 때문입니다. 이 자동화 시스템의 핵심은 LLM에게 단순히 "블로그 글 써줘"라고 요청하는 것이 아니라, 글의 목표를 담은 `brief`와 구체적인 구조인 `outline`을 제공하여 원하는 결과물을 정교하게 유도하는 것입니다. Gemini 2.5 Pro는 복잡하고 구조화된 프롬프트를 입력했을 때, 각 섹션의 요구사항을 누락하지 않고 일관된 톤앤매너로 결과물을 생성하는 능력이 뛰어났습니다. 특히 기술적인 내용을 다룰 때, 제공된 `outline`의 논리적 흐름을 충실히 따라가는 모습이 인상적이었습니다. 물론 이는 다른 최신 LLM들도 충분히 가능한 영역이지만, 테스트 결과 Gemini 2.5 Pro가 제가 의도한 '틀에 맞는 글쓰기'에 가장 안정적인 결과물을 보여주었습니다.

## brief와 outline을 입력 단계에서 고정한 이유

이 자동화의 가장 중요한 설계 철학은 'LLM에게 모든 것을 맡기지 않는다'는 것입니다. 제목만 던져주고 "알아서 잘 써줘"라고 요청하는 것은 편리해 보이지만, 결과물의 품질을 보장할 수 없습니다. LLM은 글의 핵심 논점이나 독자에게 전달하고자 하는 미묘한 뉘앙스를 스스로 파악할 수 없기 때문입니다. 결국 저자가 의도하지 않은 방향으로 글이 전개되거나, 일반론적인 내용으로만 채워진 결과물을 받게 될 가능성이 높습니다.

그래서 입력 단계에서 `brief`(주제/논점/결론)와 `outline`(섹션 구조)을 사람이 직접 작성하여 고정하는 방식을 택했습니다.

*   **Brief**: 이 글이 '왜' 중요한지, '무엇을' 주장하고 싶은지, 독자가 글을 읽고 '무엇을' 얻어가야 하는지를 정의합니다. 이것은 글의 '영혼'과 같습니다.
*   **Outline**: 주장을 뒷받침하기 위한 논리의 '뼈대'입니다. 각 섹션의 제목과 순서를 미리 결정함으로써 글의 전체적인 흐름과 구조를 완벽하게 통제할 수 있습니다.

이 방식은 자동화의 편리함과 저자의 통제력 사이에서 현명한 균형을 찾는 방법입니다. 글의 방향키는 여전히 저자가 굳게 쥐고 있습니다. LLM은 잘 닦인 도로 위에서 정해진 경로를 따라 운전하는 '자율주행 드라이버' 역할을 할 뿐입니다. 이 제약을 통해 우리는 LLM의 창의성(?)이 엉뚱한 곳으로 튀는 것을 방지하고, 항상 의도한 범위 내에서 일관된 품질의 초안을 얻을 수 있습니다.

## 자동 생성된 게시글 초안의 품질과 한계

그렇다면 이 시스템으로 생성된 초안의 품질은 어떨까요? 결론부터 말하면, '훌륭한 시작점'을 제공하지만 결코 '완성본'은 아닙니다. 초안은 제공된 `outline`에 따라 구조적으로 매우 탄탄하며, 각 섹션의 내용도 논리적으로 연결됩니다. 문법적인 오류도 거의 없고, 복잡한 개념도 꽤 명료하게 설명해냅니다. '빈 페이지의 공포'를 극복하고 글쓰기를 시작하게 만드는 데에는 더할 나위 없이 훌륭한 결과물입니다.

하지만 명백한 한계도 존재합니다. 첫째, **개인적인 경험과 목소리가 부재**합니다. LLM은 제가 겪었던 특정 에러, 프로젝트에서 얻은 깨달음, 동료와 나눴던 토론 같은 '진짜 이야기'를 만들어낼 수 없습니다. 둘째, **미묘한 뉘앙스나 깊이 있는 통찰이 부족**합니다. 글의 표면적인 논리는 맞지만, 그 이면에 숨겨진 트레이드오프나 실무적인 '꿀팁'까지는 담아내지 못합니다. 생성된 초안은 잘 정리된 교과서처럼 느껴질 때가 많습니다.

따라서 이 자동화 시스템의 결과물은 반드시 사람의 후반 작업을 거쳐야 합니다. 저의 역할은 생성된 초안을 바탕으로 '살을 붙이고 영혼을 불어넣는 것'입니다. 부족한 경험을 채워 넣고, 저만의 목소리로 문장을 다듬고, 더 깊이 있는 예시를 추가하는 과정이 필수적입니다. 즉, 저자는 '창작자'에서 '편집자 겸 강화자(Enhancer)'로 역할이 전환됩니다.

## 🤔 Understanding: 어디까지 자동화하고, 어디서 사람이 개입해야 할까

이 프로젝트를 통해 얻은 가장 큰 교훈은 LLM 기반 자동화의 현실적인 경계선을 설정하는 것의 중요성입니다. 우리는 '모든 것을 자동화'하려는 유혹에 빠지기 쉽지만, 창의적인 작업에서는 오히려 해가 될 수 있습니다. 이 시스템의 성공은 무엇을 자동화'했는가'보다 무엇을 자동화'하지 않았는가'에 달려 있습니다.

자동화에 적합한 영역은 명확합니다.

*   **반복적이고 기계적인 작업**: 파일 생성, 메타데이터 설정
*   **구조화된 텍스트 생성**: 정해진 개요에 따라 논리적인 문단을 만드는 작업

반드시 사람이 개입해야 하는 영역 또한 명확합니다.

*   **전략적 방향 설정**: 글의 핵심 메시지와 목표 독자를 정의하는 `brief` 작성
*   **구조 설계**: 논리의 흐름을 결정하는 `outline` 설계
*   **최종 품질 관리**: 초안에 개인적인 경험, 깊이 있는 통찰, 고유한 목소리를 더하는 퇴고 과정

<!-- ILLUSTRATION: concept -->

결국 이 시스템은 '인간 대체'가 아닌 '인간 증강(Human Augmentation)'을 목표로 합니다. 개발자가 가장 지루하고 막막하게 느끼는 부분을 기계가 대신 처리해주고, 인간은 더 창의적이고 본질적인 부분에 집중할 수 있도록 돕는 것입니다. 이는 글쓰기 생산성을 극적으로 높여주는 현실적인 트레이드오프입니다. 우리는 LLM을 모든 것을 해결해주는 마법 지팡이로 여길 것이 아니라, 명확한 지시를 내렸을 때 최고의 성능을 발휘하는 강력한 '도구'로 인식해야 합니다. 앞으로의 과제는 이 '인간-기계 협업' 모델을 어떻게 더 정교하게 다듬고 다른 창의적인 작업으로 확장해나갈 수 있을지에 대한 고민이 될 것입니다.
