---
emoji: 📚
title: n8n으로 블로그 게시글 초안을 자동 생성해보자
date: '2025-12-28'
author: JH8459
categories: Backend
thumbnail: https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-12-28/Backend/thumbnail.png
---

<!-- AI_BRIEF_START
이 글은 n8n과 Gemini 2.5 Pro, 그리고 별도의 agent-server를 조합해 기술 블로그 게시글 초안을 자동으로 생성하는 구조를 설계하고 구현한 경험을 정리한 글이다.

단순히 n8n의 기능이나 사용법을 나열하는 튜토리얼이 아니라, 왜 블로그 게시글 자동화를 고민하게 되었는지, 기존의 수동 작성 방식에는 어떤 한계가 있었는지, 그리고 실제로 자동화를 구성하면서 어떤 설계적 선택과 책임 분리가 필요했는지를 중심으로 설명하고자 한다.

특히 이 글에서는 LLM에게 모든 것을 맡기지 않고, 메타 정보와 파일 생성은 서버가 책임지고, 게시글의 방향성과 구조는 사람이 직접 정의하며, 본문 초안만을 LLM이 생성하도록 한 이유를 중요하게 다룬다.

독자는 이미 기술 블로그를 운영하고 있거나 n8n 혹은 LLM 기반 자동화에 관심이 있는 백엔드 개발자이며, "이런 자동화가 실제로 실무에서 쓸 만한가?"라는 관점에서 이 글을 읽게 된다.

최종적으로는 n8n + agent-server + Gemini 2.5 Pro 조합에서 어디까지 자동화하고, 어디서 사람이 개입하는 구조가 현실적인지에 대한 하나의 기준과 사고 과정을 공유하는 것이 목적이다.
AI_BRIEF_END -->

<!-- AI_OUTLINE_START
📚 Overview: 왜 블로그 게시글 자동화를 고민하게 되었는가
기존 기술 블로그 작성 방식의 한계
n8n을 선택한 이유와 전체 자동화 흐름
agent-server의 역할과 책임 분리
Gemini 2.5 Pro를 LLM으로 선택한 이유
brief와 outline을 입력 단계에서 고정한 이유
자동 생성된 게시글 초안의 품질과 한계
🤔 Understanding: 어디까지 자동화하고, 어디서 사람이 개입해야 할까
AI_OUTLINE_END -->

<img src="https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-12-28/Backend/banner.png"/>

## 📚 Overview

기술 블로그를 꾸준히 운영하는 것은 개발자에게 중요한 활동이지만, 동시에 상당한 시간과 노력을 요구하는 일이기도 합니다. 저 역시 아이디어를 정리하고, 구조를 잡고, 초안을 작성하고, 퇴고하는 과정에서 '글쓰기' 자체보다 글을 시작하기까지의 과정, 즉 파일 생성, 메타 정보 입력과 같은 부수적인 작업에서 오는 마찰 비용이 크다고 느껴왔습니다. "이 반복적인 준비 과정만이라도 자동화할 수 없을까?"라는 고민이 이 프로젝트의 시작이었습니다.

이 글은 단순히 n8n이나 LLM의 사용법을 설명하는 튜토리얼이 아닙니다. n8n과 Gemini 2.5 Pro, 그리고 직접 구현한 agent-server를 조합하여 블로그 게시글 초안 생성 시스템을 구축한 경험을 공유하며, 그 과정에서 했던 기술적 선택과 설계적 고민을 담았습니다. 왜 LLM에게 모든 것을 맡기지 않았는지, 왜 별도의 서버를 두어 책임을 분리했는지, 그리고 가장 중요하게는 **어디까지 자동화하고 어디부터 사람이 개입하는 것이 가장 효율적인가**에 대한 저의 결론을 이야기하고자 합니다.

이 글을 읽는 독자는 저처럼 기술 블로그 운영의 어려움을 겪고 있거나, n8n과 LLM을 활용한 실용적인 자동화 시스템 구축에 관심 있는 백엔드 개발자일 것입니다. "뜬구름 잡는 이야기가 아니라, 실제로 내 작업에 적용해 볼 만한가?"라는 질문에 대한 답을 찾아가는 과정을 함께 따라오실 수 있도록, 성공뿐만 아니라 시스템의 명확한 한계까지 솔직하게 다루겠습니다.

## 왜 블로그 게시글 자동화를 고민하게 되었는가

기술 블로그를 작성하는 행위는 단순히 정보를 나열하는 것 이상의 의미를 가집니다. 흩어져 있던 머릿속 지식을 체계적으로 구조화하고, 다른 사람에게 설명하는 과정을 통해 비로소 온전히 내 것이 되기 때문입니다. 또한, 꾸준한 글쓰기는 개인 브랜딩과 커리어에도 긍정적인 영향을 미칩니다. 저 역시 이러한 글쓰기의 가치를 잘 알고 있기에 꾸준히 블로그를 운영하려 노력해왔습니다.

하지만 '글을 써야지'라고 마음먹는 것과 실제로 첫 문장을 시작하는 것 사이에는 생각보다 높은 허들이 존재합니다. 바로 '시작하기 위한 준비 과정'입니다. 새로운 아이디어가 떠오를 때마다 에디터를 열고, `YYYY-MM-DD-slug-name.md` 형식에 맞춰 파일을 생성하고, 기존 글에서 YAML frontmatter를 복사해와 `title`, `date`, `category`, `slug` 등의 메타 정보를 수정하는 일련의 과정은 창의적인 활동이라기보다는 반복적인 노동에 가깝습니다. 이 사소하지만 귀찮은 과정들이 모여 글쓰기의 시작을 방해하는 '심리적 장벽'으로 작용했던 것입니다. 제가 자동화를 통해 해결하고 싶었던 핵심 문제는 글쓰기 자체를 대체하는 것이 아니라, 바로 이 시작의 마찰을 없애는 것이었습니다.

## 기존 기술 블로그 작성 방식의 한계

기존에 제가 기술 블로그 게시글 하나를 작성하기 시작하는 과정은 다음과 같았습니다.

1.  글의 주제와 대략적인 개요를 머릿속이나 메모장에 구상합니다.
2.  VS Code와 같은 에디터를 실행하고, 블로그 프로젝트 폴더로 이동합니다.
3.  `_posts` 디렉터리 안에 `2025-12-28-n8n으로-블로그-게시글-초안을-자동-생성해보자.md`와 같은 형식으로 새 마크다운 파일을 생성합니다. 파일명을 정하는 것부터 이미 작은 고민의 시작입니다.
4.  이전에 작성했던 다른 게시글을 열어 YAML frontmatter 부분을 그대로 복사하여 새 파일에 붙여넣습니다.
5.  붙여넣은 frontmatter의 `title`, `date`, `slug`, `category` 등의 값을 새로 쓸 글에 맞게 하나씩 수정합니다. 이 과정에서 오타가 발생하거나 날짜 형식을 잘못 입력하는 실수가 종종 발생합니다.
6.  이 모든 준비가 끝나고 나서야 비로소 본문 첫 문장을 작성하기 시작합니다.

이 과정의 가장 큰 한계는 '비효율적인 컨텍스트 스위칭'입니다. 아이디어를 콘텐츠로 전환하는 창의적인 흐름에 집중해야 할 시간에, 파일명 규칙이나 YAML 문법 같은 기술적인 세부사항에 신경을 써야만 합니다. 각 단계는 몇 초에서 몇 분밖에 걸리지 않지만, 이 작은 마찰들이 모여 글쓰기를 시작하려는 의지를 꺾고 "나중에 하자"며 미루게 만드는 주된 원인이었습니다. 자동화의 목표는 이 1번부터 5번까지의 과정을 단 하나의 액션으로 통합하여, 제가 오직 '무엇을 쓸 것인가'에만 집중할 수 있는 환경을 만드는 것이었습니다.

## n8n을 선택한 이유와 전체 자동화 흐름

이 문제를 해결하기 위해 여러 자동화 도구를 검토했습니다. Zapier 같은 SaaS는 사용이 간편하지만 복잡한 로직을 구현하거나 외부 서비스와 유연하게 연동하기에는 비용과 기능적 제약이 있었습니다. 반면, 처음부터 모든 것을 코드로 작성하는 방식은 자유도가 높지만, 워크플로우를 시각적으로 파악하기 어렵고 유지보수 비용이 증가한다는 단점이 있었습니다.

n8n은 이 두 가지 방식의 장점을 절묘하게 결합한 도구였습니다. 오픈소스로 직접 서버에 설치(Self-hosted)할 수 있어 비용 부담이 적고 데이터 통제권을 가질 수 있으며, 노드 기반의 비주얼 워크플로우 에디터는 전체 자동화 흐름을 한눈에 파악하고 수정하기 용이하게 만들어 주었습니다. 특히 HTTP Request 노드, Function 노드(JavaScript 코드 실행) 등 강력한 기본 노드를 제공하여 외부 API나 직접 만든 서버와 연동하는 데 매우 유연했습니다.

<!-- ILLUSTRATION: diagram -->

전체 자동화 흐름은 다음과 같이 설계했습니다.

1.  **입력 (Human):** 사용자인 저는 Notion이나 간단한 웹 양식을 통해 게시글의 핵심 아이디어(`Brief`)와 구조(`Outline`)를 텍스트로 입력합니다.
2.  **트리거 (n8n):** 입력이 완료되면 n8n의 Webhook 노드가 호출되어 워크플로우가 시작됩니다.
3.  **오케스트레이션 (n8n):** n8n은 Webhook으로 전달받은 `Brief`와 `Outline` 데이터를 받아, 미리 정의된 다음 단계를 실행합니다.
4.  **핵심 로직 처리 (agent-server):** n8n은 이 데이터를 직접 구현한 `agent-server`의 특정 API 엔드포인트로 전달합니다.
5.  **LLM 호출 (agent-server -> Gemini):** `agent-server`는 전달받은 데이터를 바탕으로 Gemini 2.5 Pro API에 요청할 프롬프트를 동적으로 생성하고, API를 호출하여 게시글 본문 초안을 생성합니다.
6.  **파일 생성 및 후처리 (agent-server):** `agent-server`는 LLM으로부터 받은 본문 초안과 n8n에서 전달받은 메타 정보를 조합하여 완전한 마크다운 파일(.md)을 생성하고, YAML frontmatter까지 채워 지정된 경로에 저장합니다.
7.  **결과 알림 (n8n):** `agent-server`로부터 파일 생성 성공 여부를 응답받은 n8n은 Slack이나 이메일 등으로 저에게 알림을 보내 작업을 마무리합니다.

## agent-server의 역할과 책임 분리

"왜 n8n에서 직접 LLM API를 호출하고 파일 시스템에 접근하지 않고, 굳이 별도의 `agent-server`를 만들었는가?"라는 질문이 나올 수 있습니다. n8n의 Function 노드나 Execute Command 노드를 사용하면 이론적으로는 가능하기 때문입니다. 하지만 저는 더 나은 유지보수성과 확장성을 위해 명확한 책임 분리가 필요하다고 판단했습니다.

**n8n의 책임은 '오케스트레이터(Orchestrator)'**에 있습니다. 즉, '언제', '어떤 데이터를 가지고', '어떤 서비스를 호출할지'를 결정하고 연결하는 역할에만 집중하도록 했습니다. n8n은 전체 워크플로우의 지휘자이며, 각 단계의 구체적인 구현 내용은 알 필요가 없습니다. 이는 워크플로우의 가독성을 높이고, 각 서비스의 변경이 다른 부분에 미치는 영향을 최소화합니다.

반면, **`agent-server`의 책임은 '핵심 비즈니스 로직'**을 담당하는 것입니다. 이 시스템에서 핵심 로직은 두 가지입니다. 첫째, LLM과의 상호작용입니다. 복잡한 프롬프트 템플릿 관리, API Key 같은 민감 정보의 안전한 보관, LLM 응답 파싱 및 예외 처리는 n8n의 작은 코드 블록에서 다루기보다 Node.js나 Python 같은 본격적인 프로그래밍 환경에서 처리하는 것이 훨씬 안정적이고 효율적입니다. 둘째, 파일 시스템 처리입니다. slug 생성 규칙, YAML frontmatter 포맷팅, 정확한 경로에 파일 저장 등은 운영체제와 밀접한 작업이므로, 이 역시 별도의 서버에서 전담하는 것이 훨씬 깔끔하고 테스트하기도 용이합니다.

<!-- ILLUSTRATION: concept -->

이러한 책임 분리를 통해 n8n은 '흐름'에만 집중하고, `agent-server`는 '구현'에만 집중할 수 있게 되었습니다. 만약 나중에 LLM을 Gemini에서 다른 모델로 바꾸거나, 파일 저장 위치를 로컬이 아닌 Git Repository로 변경하더라도 n8n 워크플로우는 전혀 수정할 필요 없이 `agent-server`의 코드만 변경하면 됩니다. 이것이 바로 마이크로서비스 아키텍처에서 추구하는 관심사의 분리(Separation of Concerns) 원칙을 소규모 자동화 시스템에 적용한 결과입니다.

## Gemini 2.5 Pro를 LLM으로 선택한 이유

게시글 초안 생성을 위한 LLM을 선택할 때, 몇 가지 모델(GPT-4o, Claude 3.5 Sonnet 등)을 함께 고려했습니다. 최종적으로 Gemini 2.5 Pro를 선택한 이유는 다음과 같은 실용적인 장점들 때문이었습니다.

첫째, **긴 컨텍스트와 복잡한 지시사항 이해 능력**이 뛰어났습니다. 제가 입력하는 `Brief`와 `Outline`은 단순한 키워드가 아니라, 글의 목표, 타겟 독자, 톤앤매너, 그리고 각 섹션에서 다뤄야 할 구체적인 내용까지 포함하는 상당히 복잡한 지시사항입니다. Gemini 2.5 Pro는 이 모든 맥락을 안정적으로 이해하고, 제가 의도한 구조와 흐름을 거의 그대로 반영한 결과물을 만들어주었습니다. 특히 "Outline의 각 항목을 Markdown '##' 섹션 제목으로 사용하고, 순서를 절대 바꾸지 말 것"과 같은 제약 조건을 매우 잘 준수했습니다.

둘째, **기술적인 주제에 대한 한국어 글쓰기 품질**이 만족스러웠습니다. 기술 블로그는 단순히 문장이 유려한 것을 넘어, 전문 용어를 정확하게 사용하고 논리적 흐름을 일관되게 유지하는 것이 중요합니다. 테스트 결과, Gemini 2.5 Pro는 백엔드 개발과 관련된 복잡한 개념을 비교적 자연스러운 한국어 문장으로 풀어내는 능력이 우수했습니다. 물론 100% 완벽하지는 않지만, 초안으로서의 역할을 충분히 해낼 수 있는 수준의 결과물을 제공했습니다.

마지막으로, **API의 응답 속도와 비용 효율성**도 중요한 고려사항이었습니다. 초안 생성은 글을 쓸 때마다 발생하는 작업이므로, 지나치게 느리거나 비용이 많이 든다면 자동화의 의미가 퇴색됩니다. Gemini 2.5 Pro는 합리적인 비용으로 제가 요구하는 품질의 텍스트를 생성하는 데 필요한 성능을 충분히 보여주었기에, 지속 가능한 자동화 시스템을 위한 최적의 선택이라고 판단했습니다.

## brief와 outline을 입력 단계에서 고정한 이유

이 자동화 시스템의 가장 중요한 설계 원칙 중 하나는 **"LLM에게 창의성을 모두 위임하지 않는다"**는 것입니다. 단순히 "n8n에 대한 글을 써줘"라고 요청하면, LLM은 그럴듯하지만 핵심이 없고 어디서나 볼 수 있는 일반적인 내용의 글을 생성할 가능성이 높습니다. 이런 결과물은 오히려 처음부터 직접 쓰는 것보다 더 많은 수정 작업을 요구하며, 자동화의 목적을 완전히 잃게 만듭니다.

이 문제를 해결하기 위해, 저는 LLM의 역할을 '자유로운 작가'가 아닌 '설계도를 충실히 따르는 숙련된 기술자'로 제한했습니다. 이 설계도가 바로 `Brief`와 `Outline`입니다.

-   **Brief (설계 의도):** 이 글을 왜 쓰는지, 누구를 대상으로 하는지, 어떤 핵심 메시지를 전달하고 싶은지를 명확히 정의합니다. 이는 글의 '영혼'에 해당하며, LLM이 전체적인 톤앤매너와 방향성을 잃지 않도록 잡아주는 역할을 합니다.
-   **Outline (구조 설계도):** 글의 구체적인 뼈대입니다. 각 섹션의 제목과 순서, 그리고 각 섹션에서 다뤄야 할 핵심 내용을 명시합니다. 이는 글의 논리적 흐름을 통제하고, 결과물의 예측 가능성을 극적으로 높여줍니다.

이처럼 인간이 글의 전략적인 부분(Why, What, How)을 직접 통제하고, LLM은 그 전략을 바탕으로 문장을 채워나가는 전술적인 역할(Fleshing out)을 수행하도록 역할을 분담한 것입니다. 이 접근 방식은 LLM의 강력한 언어 생성 능력은 최대한 활용하면서도, 결과물이 저의 의도에서 벗어나지 않도록 하는 가장 효과적인 방법이었습니다. 자동화의 목표는 '생각 없는 글의 양산'이 아니라 '내 생각을 더 빠르게 글로 옮기는 것'이기 때문입니다.

## 자동 생성된 게시글 초안의 품질과 한계

그렇다면 이 시스템으로 생성된 초안은 어느 정도 수준일까요? 결론부터 말하자면, "완성된 글이 아니라, 정말 훌륭한 '초안'"입니다. 이 시스템은 '백지상태의 공포'를 완벽하게 해결해 줍니다. 글의 전체 구조와 섹션별 내용이 채워진 상태로 시작하기 때문에, 저는 글쓰기에서 가장 힘든 초기 단계를 건너뛰고 곧바로 '다듬기'와 '개선하기' 단계로 들어갈 수 있습니다.

초안의 품질은 매우 만족스럽습니다. `Outline`에 명시한 대로 각 섹션이 논리적으로 구성되어 있고, `Brief`에서 요청한 톤앤매너도 잘 반영되어 있습니다. 문법적인 오류도 거의 없으며, 각 문단이 유기적으로 연결되려는 노력도 보입니다. 이 정도면 전체 글의 약 70~80%는 완성되었다고 볼 수 있습니다. 하지만 이 시스템의 명확한 한계 또한 존재합니다.

-   **개인적인 경험과 깊이의 부재:** LLM은 제가 겪었던 특정 프로젝트의 경험, 실패담, 그 과정에서 얻은 미묘한 깨달음 같은 '진짜 이야기'를 만들어낼 수 없습니다. 초안에 저의 목소리와 깊이를 더하는 것은 온전히 저의 몫입니다.
-   **기술적 정확성 검증 필수:** LLM은 때때로 사실이 아닌 내용을 그럴듯하게 서술(Hallucination)하거나, 코드 예제의 미묘한 버그를 포함할 수 있습니다. 생성된 모든 기술적인 내용과 코드는 반드시 전문가인 제가 직접 검증하고 수정해야 합니다.
-   **미묘한 뉘앙스와 표현:** "이 표현보다는 저 표현이 더 독자에게 와닿겠다"와 같은 미묘한 뉘앙스 조정은 여전히 인간의 영역입니다. 초안의 문장을 더 날카롭고 흡입력 있게 만드는 퇴고 과정은 필수적입니다.

결국 이 자동화 시스템은 저를 대체하는 것이 아니라, 저의 시간을 가장 가치 있는 곳에 쓰도록 돕는 강력한 '조수' 역할을 합니다. 반복적인 뼈대 작업을 기계에 맡기고, 저는 창의적이고 전문적인 영역에만 집중할 수 있게 된 것입니다.

## 🤔 Understanding: 어디까지 자동화하고, 어디서 사람이 개입해야 할까

이 프로젝트를 통해 제가 내린 결론은 명확합니다. 성공적인 자동화는 '모든 것을 자동화'하려는 시도가 아니라, **'기계가 잘하는 일과 사람이 잘하는 일을 명확히 구분하고, 그 경계를 현명하게 설계하는 것'**에 달려있다는 것입니다.

우리가 자동화해야 할 대상은 창의적인 사고나 전문적인 판단이 아니라, 반복적이고 정형화된, 그래서 우리를 지치게 만드는 '마찰'입니다. 블로그 글쓰기 과정에서 파일 생성, 메타 정보 입력, 기본 구조 잡기는 전형적인 '마찰'에 해당합니다. 반면, 글의 핵심 주제와 논점을 정하고, 독자의 공감을 얻을 경험을 녹여내며, 기술적 정확성을 보장하는 것은 인간의 고유한 '가치 창출' 영역입니다.

이 시스템은 바로 그 경계선 위에 서 있습니다.

-   **기계의 역할 (자동화 영역):**
    -   Webhook을 통해 입력을 받아 전체 프로세스를 시작.
    -   정해진 규칙에 따라 파일명과 slug를 생성.
    -   YAML frontmatter를 포함한 마크다운 파일 템플릿을 생성.
    -   인간이 제공한 `Brief`와 `Outline`을 기반으로 구조화된 본문 초안을 생성.
-   **사람의 역할 (개입 영역):**
    -   글의 방향성과 핵심 메시지를 담은 `Brief`를 작성.
    -   논리적 흐름을 결정하는 `Outline`을 설계.
    -   생성된 초안에 개인적인 경험과 깊이를 더하고, 목소리를 입힘.
    -   기술적 사실 관계를 검증하고, 코드를 수정 및 테스트.
    -   전체적인 완성도를 높이기 위한 최종 퇴고.

이러한 역할 분담은 초기 시스템 구축에 드는 시간과 노력을 상쇄하고도 남을 만큼, 장기적으로 글쓰기 생산성을 극적으로 향상시켰습니다. 이제 저에게 블로그 글쓰기는 더 이상 막막한 백지에서 시작하는 두려운 작업이 아니라, 잘 준비된 재료를 가지고 요리하는 즐거운 과정이 되었습니다. 이 글 역시 바로 이 시스템을 통해 생성된 초안을 바탕으로 완성되었습니다. 여러분도 자신의 업무에서 반복되는 '마찰'이 무엇인지 찾아보고, 그 부분을 기계에 넘겨주는 자동화를 시도해 보시는 것은 어떨까요? 그 시작점에 이 글이 작은 영감이 되기를 바랍니다.
