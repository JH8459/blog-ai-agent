---
emoji: 📚
title: n8n으로 블로그 게시글 초안을 자동 생성해보자
date: '2025-12-27'
author: JH8459
categories: Backend
thumbnail: https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-12-27/Backend/thumbnail.png
---

<!-- AI_BRIEF_START
이 글은 n8n과 Gemini 2.5 Pro, 그리고 별도의 agent-server를 조합해 기술 블로그 게시글 초안을 자동으로 생성하는 구조를 설계하고 구현한 경험을 정리한 글이다.

단순히 n8n의 기능이나 사용법을 나열하는 튜토리얼이 아니라, 왜 블로그 게시글 자동화를 고민하게 되었는지, 기존의 수동 작성 방식에는 어떤 한계가 있었는지, 그리고 실제로 자동화를 구성하면서 어떤 설계적 선택과 책임 분리가 필요했는지를 중심으로 설명하고자 한다.

특히 이 글에서는 LLM에게 모든 것을 맡기지 않고, 메타 정보와 파일 생성은 서버가 책임지고, 게시글의 방향성과 구조는 사람이 직접 정의하며, 본문 초안만을 LLM이 생성하도록 한 이유를 중요하게 다룬다.

독자는 이미 기술 블로그를 운영하고 있거나 n8n 혹은 LLM 기반 자동화에 관심이 있는 백엔드 개발자이며, "이런 자동화가 실제로 실무에서 쓸 만한가?"라는 관점에서 이 글을 읽게 된다.

최종적으로는 n8n + agent-server + Gemini 2.5 Pro 조합에서 어디까지 자동화하고, 어디서 사람이 개입하는 구조가 현실적인지에 대한 하나의 기준과 사고 과정을 공유하는 것이 목적이다.
AI_BRIEF_END -->

<!-- AI_OUTLINE_START
📚 Overview: 왜 블로그 게시글 자동화를 고민하게 되었는가
기존 기술 블로그 작성 방식의 한계
n8n을 선택한 이유와 전체 자동화 흐름
agent-server의 역할과 책임 분리
Gemini 2.5 Pro를 LLM으로 선택한 이유
brief와 outline을 입력 단계에서 고정한 이유
자동 생성된 게시글 초안의 품질과 한계
🤔 Understanding: 어디까지 자동화하고, 어디서 사람이 개입해야 할까
AI_OUTLINE_END -->

<img src="https://jh8459.s3.ap-northeast-2.amazonaws.com/blog/2025-12-27/Backend/banner.png"/>

## 📚 Overview: 왜 블로그 게시글 자동화를 고민하게 되었는가

기술 블로그를 꾸준히 운영하는 것은 생각보다 많은 에너지를 필요로 합니다. 단순히 코드를 짜고 기능을 구현하는 것과는 다른 종류의 노동이죠. 아이디어를 구체화하고, 목차를 잡고, 초안을 작성하고, 퇴고하는 모든 과정에는 상당한 시간과 정신적 비용이 따릅니다. 특히 가장 큰 허들은 '시작' 그 자체입니다. 빈 에디터 화면 앞에서 첫 문장을 써 내려가는 막막함, 그리고 포스트마다 반복되는 파일 생성, 슬러그(slug) 결정, YAML frontmatter 작성 같은 기계적인 작업들이 글쓰기의 흐름을 방해하곤 합니다.

이 글은 바로 그 '시작의 허들'을 낮추기 위한 고민에서 출발했습니다. 어떻게 하면 기술 블로그 작성 과정에서 가장 반복적이고 가치가 낮은 부분을 자동화하여, 오롯이 '생각'과 '경험'을 녹여내는 핵심 작업에만 집중할 수 있을까? 이 질문에 대한 답을 찾기 위해 n8n, 별도의 에이전트 서버(agent-server), 그리고 Gemini 2.5 Pro를 조합하여 블로그 게시글 초안 생성 파이프라인을 구축한 경험을 공유하고자 합니다. 이 글은 단순한 튜토리얼이 아닙니다. 왜 이런 구조를 선택했는지, 각 컴포넌트의 책임은 어떻게 분리했는지, 그리고 어디까지를 자동화의 영역으로 삼고 어디부터 사람의 개입이 필수적인지에 대한 설계적 고민과 트레이드오프를 담았습니다.

## 기존 기술 블로그 작성 방식의 한계

자동화를 고민하기 전, 저의 블로그 글쓰기 과정은 전형적인 수동 방식이었습니다. 새로운 글을 쓰기로 마음먹으면 다음과 같은 절차를 밟아야 했습니다.

1.  **파일 생성**: `YYYY-MM-DD-my-new-post-title.md` 형식에 맞춰 마크다운 파일을 생성합니다.
2.  **Frontmatter 작성**: 파일 상단에 `title`, `date`, `category`, `slug` 등의 메타 정보를 YAML 형식으로 채워 넣습니다. 이 과정에서 날짜 형식을 맞추고, slug를 정하는 등 사소하지만 귀찮은 작업이 반복됩니다.
3.  **기본 구조 잡기**: `## 서론`, `## 본론`, `## 결론`과 같은 기본적인 마크다운 헤더를 입력하며 글의 뼈대를 세웁니다.
4.  **초안 작성**: 비로소 본문 내용을 채워 넣기 시작합니다.

문제는 1번부터 3번까지의 과정이 창의성과는 거리가 먼, 지극히 기계적인 작업이라는 점입니다. 글의 핵심 아이디어가 머릿속에 떠올라도, 이 준비 단계를 거치면서 글쓰기의 추진력이 꺾이는 경우가 많았습니다. 특히 여러 개의 글을 동시에 기획하거나 빠르게 아이디어를 스케치하고 싶을 때, 이 과정은 명백한 병목(bottleneck)으로 작용했습니다. 결국 '글의 본질'에 집중하기보다 '글을 쓰기 위한 준비'에 에너지를 소모하게 되는 비효율이 발생한 것입니다. 저는 이 반복적인 준비 과정을 제거하고, 아이디어를 곧바로 초안으로 연결하는 더 나은 방법이 필요했습니다.

## n8n을 선택한 이유와 전체 자동화 흐름

이 문제를 해결하기 위해 여러 자동화 도구를 검토했지만, 최종적으로 n8n을 선택했습니다. n8n은 워크플로우를 시각적인 노드(node) 기반으로 설계할 수 있어 복잡한 로직도 직관적으로 이해하고 수정하기 쉽다는 장점이 있습니다. 특히 HTTP 요청, 파일 시스템 접근, 다양한 LLM 서비스 연동 등 백엔드 개발자에게 익숙한 요소들을 쉽게 오케스트레이션할 수 있다는 점이 매력적이었습니다. 코드로 모든 것을 구현하는 것보다 프로토타이핑이 훨씬 빠르고, 비즈니스 로직의 흐름을 한눈에 파악할 수 있다는 것은 큰 이점입니다.

제가 구성한 전체 자동화 흐름은 다음과 같습니다.

1.  **Trigger (Webhook)**: 외부에서 HTTP POST 요청으로 `brief`(글의 핵심 요약)와 `outline`(글의 목차 구조) 데이터를 받으면 워크플로우가 시작됩니다.
2.  **Call Agent-Server**: n8n은 받은 `brief`와 `outline`을 그대로 커스텀 `agent-server`로 전달합니다. 이 서버는 글의 메타 정보(slug, 파일명, 날짜 등)를 생성하고, LLM에 전달할 최종 프롬프트를 조립하는 역할을 합니다.
3.  **Call LLM (Gemini 2.5 Pro)**: `agent-server`가 생성한 프롬프트를 n8n이 받아 Gemini 2.5 Pro API를 호출합니다. LLM은 이 프롬프트를 기반으로 마크다운 형식의 본문 초안을 생성합니다.
4.  **Save File**: `agent-server`는 LLM이 생성한 본문과 자신이 만든 메타 정보를 합쳐 최종 마크다운 파일을 로컬 파일 시스템에 저장합니다.
5.  **Notify**: 모든 과정이 완료되면 슬랙(Slack)으로 알림을 보내 작업이 성공적으로 끝났음을 알립니다.

<!-- ILLUSTRATION: diagram -->

이 흐름에서 n8n의 역할은 '오케스트레이터'에 가깝습니다. 각 단계를 연결하고 데이터를 전달하는 접착제 역할을 수행하며, 실제 비즈니스 로직이나 복잡한 연산은 다른 전문화된 컴포넌트에 위임합니다.

## agent-server의 역할과 책임 분리

"왜 굳이 별도의 `agent-server`를 두었을까? n8n의 Function 노드나 Code 노드로 처리하면 되지 않을까?" 라고 생각할 수 있습니다. 저 역시 처음에는 n8n 내에서 모든 것을 해결하려 했습니다. 하지만 몇 가지 중요한 이유 때문에 책임을 분리하는 방향으로 설계를 변경했습니다.

첫째, **결정론적 로직과 비결정론적 로직의 분리**입니다. 파일명을 생성하고, slug를 URL-safe하게 변환하고, YAML frontmatter를 정해진 형식에 맞게 만드는 작업은 예측 가능하고 테스트가 용이한 '결정론적(deterministic)' 로직입니다. 반면, LLM을 통해 글의 초안을 생성하는 것은 동일한 입력에도 결과가 달라질 수 있는 '비결정론적(non-deterministic)' 작업입니다. 이 두 종류의 로직을 한곳에 섞으면 시스템의 복잡도가 증가하고 유지보수가 어려워집니다. `agent-server`는 결정론적 로직을 전담하여 안정성과 테스트 용이성을 확보하고, LLM은 창의적인 텍스트 생성이라는 본연의 역할에만 집중하도록 했습니다.

둘째, **확장성과 보안**입니다. 만약 나중에 파일 저장 위치를 로컬이 아닌 AWS S3로 변경하거나, 글감 관리를 위해 데이터베이스 연동이 필요해진다면 `agent-server`의 코드만 수정하면 됩니다. n8n 워크플로우 자체는 거의 변경할 필요가 없죠. 또한, 파일 시스템 접근이나 민감한 API 키 관리 같은 보안에 민감한 작업을 n8n의 실행 환경에서 직접 다루는 것보다, 잘 통제된 별도의 서버 환경에서 처리하는 것이 훨씬 안전합니다. 결국, `agent-server`는 '파일 및 메타데이터 생성'이라는 명확한 책임을 가진 마이크로서비스 역할을 수행하게 됩니다.

<!-- ILLUSTRATION: concept -->

이러한 책임 분리를 통해 n8n은 '무엇을 할지(Orchestration)'에 집중하고, `agent-server`는 '어떻게 할지(Implementation)'에 집중하는 명확한 구조를 만들 수 있었습니다.

## Gemini 2.5 Pro를 LLM으로 선택한 이유

LLM 선택은 자동화 품질에 직접적인 영향을 미치는 중요한 결정이었습니다. 여러 모델을 검토한 끝에 Gemini 2.5 Pro를 선택한 이유는 몇 가지 실용적인 장점 때문입니다.

가장 큰 이유는 **긴 컨텍스트 처리 능력과 논리적 추론 능력**입니다. 기술 블로그 초안을 생성하기 위해서는 단순히 몇 개의 키워드를 나열하는 것만으로는 부족합니다. 제가 작성한 `brief`(이 글이 왜 중요한가, 어떤 문제를 다루는가)와 `outline`(각 섹션에서 어떤 내용을 다룰 것인가)의 의도를 정확히 파악하고, 그 구조에 맞춰 일관성 있는 글을 생성해야 합니다. Gemini 2.5 Pro는 긴 프롬프트를 안정적으로 소화하고, 각 섹션 간의 논리적 연결성을 유지하며 글을 전개하는 능력에서 만족스러운 성능을 보여주었습니다.

또한, **마크다운 형식에 대한 이해도**가 높다는 점도 중요했습니다. 코드 블록, 인용, 목록 등 기술 블로그에서 자주 사용하는 마크다운 문법을 프롬프트의 요구사항에 맞게 정확하게 생성해 주었습니다. 이는 후처리 작업을 최소화하고, 생성된 초안을 거의 그대로 에디터에서 열어 수정 작업을 시작할 수 있게 해준다는 의미입니다. 물론 다른 훌륭한 모델들도 많지만, 제가 시도했던 시점에서는 기술적인 내용을 구조에 맞춰 풀어내는 능력과 마크다운 생성 품질 면에서 Gemini 2.5 Pro가 가장 균형 잡힌 선택지였습니다.

## brief와 outline을 입력 단계에서 고정한 이유

이번 자동화 설계에서 가장 중요한 원칙 중 하나는 "LLM에게 모든 것을 맡기지 않는다"는 것이었습니다. 단순히 'n8n에 대한 글을 써줘'와 같이 막연한 지시를 내리는 대신, 제가 직접 `brief`와 `outline`을 작성하여 입력값으로 제공하는 방식을 고수했습니다. 이는 자동화의 결과물에 대한 통제권을 사람이 계속 쥐고 있기 위함입니다.

`brief`는 글의 영혼과 같습니다. 이 글을 통해 독자에게 어떤 가치를 전달하고 싶은지, 어떤 문제를 해결하고자 하는지에 대한 핵심적인 방향성을 담고 있습니다. `outline`은 글의 뼈대입니다. 어떤 순서로 논리를 전개하고, 각 부분에서 어떤 내용을 다룰지 명확하게 정의합니다. 이 두 가지를 사람이 직접 작성함으로써, LLM은 정해진 길 위에서만 글을 쓰게 됩니다. 즉, LLM의 역할은 '창작자'가 아니라, 아이디어를 구체적인 문장으로 풀어내는 '숙련된 조수'로 한정됩니다.

만약 이 과정을 생략하고 LLM에게 주제만 던져주면, 표면적으로는 그럴듯해 보이지만 깊이나 독창적인 관점이 부족한, 일반론적인 글이 나올 확률이 높습니다. 기술 블로그의 진정한 가치는 개발자의 경험과 깊이 있는 고민에서 나옵니다. `brief`와 `outline`을 직접 작성하는 행위는 바로 그 가치를 초안에 주입하는 과정입니다. 자동화의 목표는 사람의 생각을 대체하는 것이 아니라, 그 생각을 더 빠르고 효율적으로 글로 옮길 수 있도록 돕는 것이어야 합니다.

## 자동 생성된 게시글 초안의 품질과 한계

그렇다면 이 시스템으로 생성된 초안의 품질은 어느 정도일까요? 결론부터 말하자면 '매우 훌륭한 첫 번째 초안(First Draft)' 수준입니다. 제가 정의한 `outline` 구조를 정확히 따르며, 각 섹션의 제목 아래에 `brief`의 의도에 맞는 내용을 논리적으로 채워 넣습니다. 문법적인 오류가 거의 없고, 기술 용어도 적절하게 사용합니다. 덕분에 빈 화면을 마주하는 막막함 없이, 이미 뼈와 살이 붙은 결과물을 가지고 곧바로 '퇴고'와 '개인적인 경험 추가' 단계로 넘어갈 수 있습니다. 글쓰기 시작에 필요했던 에너지를 획기적으로 줄여준 셈입니다.

하지만 명백한 한계도 존재합니다. 첫째, **개인적인 경험과 비유의 부재**입니다. LLM은 제가 겪었던 특정 버그, 프로젝트에서 내렸던 어려운 결정, 동료와의 토론 같은 구체적인 경험을 알지 못합니다. 생성된 초안은 다소 교과서적이거나 일반적인 내용으로 채워져 있어, 글에 생동감과 설득력을 더하는 것은 온전히 저의 몫입니다. 둘째, **미묘한 뉘앙스와 톤 조절의 한계**입니다. 제가 선호하는 특유의 문체나 유머를 완벽하게 흉내 내지는 못합니다. 결국 초안을 다듬는 과정에서 저만의 목소리를 입히는 작업은 필수적입니다. 이 자동화 시스템은 '출판 가능한 최종본'을 만드는 것이 아니라, '글쓰기 과정에서 가장 고통스러운 0%에서 70%까지의 과정을 단축'시켜주는 도구로 이해해야 합니다.

## 🤔 Understanding: 어디까지 자동화하고, 어디서 사람이 개입해야 할까

이번 프로젝트를 통해 블로그 게시글 작성 자동화에 대한 저만의 기준을 세울 수 있었습니다. 핵심은 **'전략'과 '실행'을 분리하고, 사람은 '전략'에 집중하는 것**입니다. 글의 방향성을 정하고(Brief), 구조를 설계하는(Outline) 것은 사람이 해야 할 고유한 전략의 영역입니다. 이 부분까지 LLM에게 위임하는 순간, 글은 나의 생각과 경험을 담은 창작물이 아니라 그저 짜깁기된 정보의 나열이 될 위험이 큽니다.

반면, 결정된 전략에 따라 반복적인 파일을 생성하고(agent-server), 구조에 맞춰 뼈대를 채우는(LLM) 작업은 자동화하기에 가장 이상적인 '실행'의 영역입니다. 이 구조는 자동화의 효율성을 극대화하면서도 결과물의 품질에 대한 통제권을 잃지 않는 현실적인 균형점이라고 생각합니다. n8n과 `agent-server`, 그리고 LLM의 조합은 이 균형을 기술적으로 구현하기 위한 훌륭한 도구였습니다.

결론적으로, '쓸 만한' 자동화는 모든 것을 기계에 맡기는 완전 자동화가 아니라, 사람과 기계가 각자 가장 잘하는 일에 집중하는 '협업 자동화(Collaborative Automation)'에 가깝습니다. 이 시스템은 저를 글쓰기에서 해방시켜주는 것이 아니라, 제가 더 가치 있는 글쓰기 활동, 즉 고민하고, 경험을 녹여내고, 생각을 다듬는 일에 더 많은 시간을 쓸 수 있도록 도와주는 강력한 조수입니다. 앞으로는 이 초안 생성 파이프라인을 더욱 고도화하여, 이미지 생성이나 관련 자료 리서치 같은 다른 반복적인 작업들도 자동화의 영역으로 가져와 볼 계획입니다.
